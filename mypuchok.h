
#ifndef mypuchokH
#define mypuchokH
//---------------------------------------------------------------------------
#include "mymath.h"
#define _ZERO_CHECK 1                           // нужна ли проверка на близость к НУЛЮ
#define _DEFRAG_N 5.0                           // количество зон Френеля учитывающихся в "ShiftMidRange"
#define PUCHOK_MIN_DELTAS_FOR_TRANSFORM 4       // для функции "Transform"
                                                // минимальный диаметр НОВОГО пучка отнесённый к расстоянию между узлами СТАРОГО пучка
//---------------------------------------------------------------------------
class Puchok
{
public:
// ПЕРЕМЕННЫЕ ИНИЦИАЛИЗАЦИИ ОБЪЕКТА
    bool    _inited;        // инициализирован или нет
    int     _rang;          // количество внутренних узлов вдоль стороны >=3 и нечётно
                            // КРАЯ НЕ СЧИТАЮТСЯ И ВСЕГДА РАВНЫ НУЛЮ, в отличие от класса "Sreda"
    int     _N;             // общее количество узлов = _rang*_rang

// ПЕРЕМЕНЫЕ ОПРЕДЕЛЯЮЩИЕ ПАРАМЕТРЫ ПУЧКА
    double  _D;             // поперечный размер квадратного сечения пучка [мм]
                            // для сферического ВФ - расстояние между краями [мм]
                            // ВСЕГДА НУЛЕВЫЕ края тоже считаются и входят в "_D"
    double  _F;             // радиус кривизны волнового фронта [мм]
                            // равен НУЛЮ если плоский фронт
    double  _Lambda;        // длина волны [мм]
    double  _H;             // расстояние между соседними узлами [мм]

    Complex *_E;            // значения напряжённостей поля в узлах [В/мм]
                            // _E[j*_rang + i] = напряжённость в узле, соответствующем i-ому столбцу и j-ой строке
                            // j=0 и i=0 соответствуют левому нижнему узлу
                            // не в счёт ВСЕГДА НУЛЕВЫХ краёв
// ПЕРЕМЕННЫЕ ПОЛОЖЕНИЯ ПУЧКА В ПРОСТРАНСТВЕ И ХАРАКТЕРИСТИКИ ЕГО ПЕРЕДВИЖЕНИЯ
    double  _centerX;       //                         [мм]
    int     _centerZ;       // координаты центра пучка [отн.ед.]

    double  _sinX;          // синус угла между осью "Oz" и направлением пучка (положителен если "_centerX" увеличивается по мере распространения пучка)
    int     _dZ;            // приращение координаты "Z" вдоль оси "Oz" [отн.ед.], может быть равен только "1" и "-1"

// КОНСТРУКТОРЫ и ДЕСТРУКТОРЫ
            Puchok();               // конструктор по умолчанию
            Puchok(const Puchok &p);// конструктор копирования пучка "p"
            ~Puchok();              // деструктор

// ФУНКЦИИ ИНИЦИАЛИЗАЦИИ и КОПИРОВАНИЯ (пучок "this" может быть неициализирован, а также МОЖНО использовать "самого себя")
    void    Clear();                // функция освобождения памяти
    bool    Init(double D, double F, double Lambda, int rang, double X, int Z, double sinX, int dZ);
                                    // функция инициализации с заданием параметров
    bool    Copy(const Puchok &p);  // функция копирования пучка "p"
    bool    Transform(const Puchok &p, double NewD, int NewRang);
                                    // копировать пучок "p" с новым поперечным размером и новой точностью
                                    // интерполяция - линейная по интенсивности (среднеквадратичная с весами по амплитуде)

// ФУНКЦИИ ПОЛУЧЕНИЯ ХАРАКТЕРИСТИК ПУЧКА
    double  FullPower() const;                                              // полная мощность пучка [Вт]
    double  DiamOfCircleWithPower(double Power) const;                      // диаметр круга (или угол) в котором находится мощность "Power"
    double  DivergenceAngle(double Ppart, double FULLANGLE, int rang) const;// угловая расходимость пучка по уровню "Ppart" мощности [рад]
                                                                            // "FULLANGLE" - максимально рассматриваемый угол (диапазон углов)
                                                                            // "rang" - количество узлов внутри угла "FULLANGLE" (определяет точность)
                                                                            // существует НЕПРОВЕРЯЕМОЕ ограничение на "FULLANGLE" - "FULLANGLE <= _Lambda/_H"

// ФУНКЦИИ РАЗЛИЧНЫХ ПРЕОБРАЗОВАНИЙ ПУЧКА
    bool    CircleDiafragm(double Diam, bool Hole, double _delta);  // обнулить всё, что за пределами (Hole == false)
                                                                    // или внутри (Hole == true) круга диаметром = Diam
                                                                    // _delta - полушаг сглаживания
    bool    YDiafragm(double Y,bool Under, double _delta);          // обнулить всё, что сверху "Y" (Under = false)
                                                                    // или снизу "Y" (Under = true)
                                                                    // _delta - полушаг сглаживания
    bool    XDiafragm(double X,bool Left, double _delta);           // обнулить всё, что справа "X" (Left = false)
                                                                    // или слева "X" (Left = true)
                                                                    // _delta - полушаг сглаживания
    bool    Sub(const Puchok &p);                   // вычитает значения пучка "p" (МОЖНО ИСПОЛЬЗОВАТЬ "самого себя")
    bool    InverseX();                             // инвертировать по координате "X" (например при отражении от зеркала)
    bool    InverseY();                             // инвертировать по координате "Y"
    bool    TransformFToPhase(double n);            // перевести учёт радиуса кривизны ВФ в фазу волны (участок с показателем преломления "n")
    bool    DefineEAsAverage(const Complex *E, double K);   // инициализировать пучок как средний между "this->_E" и "E" с весами "1.0-K" и "K" соответственно
    bool    Mul(Complex Z);                         // умножить каждое значение поля "_E[i]" на "Z"
    bool    PhaseAddition(const double *Arg);       // прибавляет к каждому значению поля "_E[i]" фазовый сдвиг "Arg[i]"
    bool    InvertInt();                            // инвертировать ИНТЕНСИВНОСТЬ относительно максимального значения
    bool    Shade(const Puchok &shadow);            // умножить каждое значение поля "(*this)._E[i]" на "p._E[i]"
    bool    CircleTurn(double Angle);               // повернуть пучок по часовой стрелке на угол "Angle"
    double  Normalize();                            // нормирует значения напряжённости и возвращает коэффициент нормировки

// ФУНКЦИИ РАСПРОСТРАНЕНИЯ (пучок "this" может быть неициализирован, а также МОЖНО использовать "самого себя")
    bool    ShiftNearRange(const Puchok &p,const Complex *s, double Hz);
            // функция распространения пучка "p" по среде с параметрами "s" на расстояние "Hz"
            // параметры среды: "real" = коэф. преломления, "imaginary" = насыщенный коэф. усиления (по интенсивности) [мм^(-1)]
            // считает волновое уравнение конечно-разностным методом, с помощью переменных направлений
            // ПОДХОДИТ ДЛЯ БЛИЖНЕЙ ЗОНЫ (для малых Hz)
            // при "p._F<0" - не должен переходить через границу, т.е. должно выполняться неравенство "Hz < |p._F|"
    bool    ShiftMidRange(const Puchok &p, Complex defparam, double Hz,int rang);
            // функция распространения пучка "p" по среде с параметрами defparam на расстояние "Hz"
            // с другим (или тем же) количеством точек, но ТЕМ ЖЕ значением параметра _H
            // считает соотношение Гюйгенса-Френеля с помощью БПФ
            // ПОДХОДИТ ДЛЯ СРЕДНЕЙ ЗОНЫ (для средних Hz)
            // при "p._F<0" - не должен переходить через границу, т.е. должно выполняться "Hz < |p._F|"
            // Apovt = Hz*p._Lambda/p._H  - координата с которой распределение будет повторяться (т.е. где фазовый множитель отличается на "_2PI")
            // существует ПРОВЕРЯЕМОЕ ограничение на "Hz" - "Apovt >= p._D*(1.0 + Hz/p._F) + sqrt(  _DEFRAG_N*p._Lambda*Hz*p._F/(Hz+p._F)  )"
            // существует НЕПРОВЕРЯЕМОЕ ограничение на "rang" - " Apovt >= p._H*(1.0 + Hz/p._F)*(rang+1)

// ФУНКЦИИ РАСЧЁТОВ ДАЛЬНЕЙ ЗОНЫ (пучок "this" может быть неициализирован, а также МОЖНО использовать "самого себя")
    bool    ShiftFarRange(const Puchok &p, double Hz, int rang, double D);
            // функция получения пучка "p" прошедшего большое расстояние "Hz"
            // с другими размером поперечного сечения и количеством точек
            // использует GetFarField и перед расчётом переводит радиус кривизны ВФ в фазу
            // ПОДХОДИТ ТОЛЬКО ДЛЯ ДАЛЬНЕЙ ЗОНЫ (для больших Hz)
            // существует НЕПРОВЕРЯЕМОЕ ограничение на "D" и "Hz" - "D/Hz <= p._Lambda/p._H" (вытекает из ограничения в "GetFarField")
    bool    WriteFarField(const Puchok &p, double Angle, int rang);
            // рассчитывает распределение в дальней зоне
            // "Angle" - полный угол, для определения границ
            // Возвращает "0" - если ошибка
            //      _H = шаг сетки по углу [рад]
            //      _D = полный угол [рад]
            //      _centerX = _centerZ = _sinX = 0
            //      _dZ = 1
            // существует НЕПРОВЕРЯЕМОЕ ограничение на "Angle" - "Angle <= _Lambda/_H"

// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
    bool    GetFarField(Complex *result, double Delta, int rang) const;
            // получает УГЛОВОЕ распреление пучка "this" в дальней зоне и записывает результат в "result"
            // "Delta" - угловое расстояние между ближайшими узлами
            // считает интеграл Кирхгофа-Френеля с помощью разделения интегрирования по координатам
            // "result" должен быть полностью подготовлен для записи (быть размера "rang*rang")
            // "rang" как и везде >=3 и нечётно
            // существует НЕПРОВЕРЯЕМОЕ ограничение на "rang" - "rang <= _Lambda/(_H*Delta)"
    double  GetAngleWithW(const Complex *field, double W,int rang) const;
            // определяет круг, в котором находится поток W (т.е. круг, в котором сумма field[i][j] равна W)
            // возвращает РАДИУС КРУГА в количестве узлов (может быть дробным)
            // "field" должен содержать данные и быть размером "rang*rang"
            // "rang" как и везде >=3 и нечётно
            // если такого потока нет в пучке или какая-либо другая ошибка - возвращает "0"
};
//---------------------------------------------------------------------------
#endif
